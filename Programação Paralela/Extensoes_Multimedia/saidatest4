
Analyzing loop at test4.c:14

test4.c:14: note: ===== analyze_loop_nest =====
test4.c:14: note: === vect_analyze_loop_form ===
test4.c:14: note: === get_loop_niters ===
test4.c:14: note: ==> get_loop_niters:65536
test4.c:14: note: === vect_analyze_data_refs ===

test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: === vect_analyze_scalar_cycles ===
test4.c:14: note: Analyze phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: Access function of PHI: {0, +, 1}_1
test4.c:14: note: step: 1,  init: 0
test4.c:14: note: Detected induction.
test4.c:14: note: Analyze phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: Analyze phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: Access function of PHI: {65536, +, 4294967295}_1
test4.c:14: note: step: 4294967295,  init: 65536
test4.c:14: note: Detected induction.
test4.c:14: note: === vect_pattern_recog ===
test4.c:14: note: vect_is_simple_use: operand _8
test4.c:14: note: def_stmt: _8 = (long unsigned int) i_19;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_is_simple_use: operand i_19
test4.c:14: note: def_stmt: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: type of def: 4.
test4.c:14: note: vect_is_simple_use: operand 8
test4.c:14: note: === vect_mark_stmts_to_be_vectorized ===
test4.c:14: note: init: phi relevant? i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: init: phi relevant? .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: init: phi relevant? ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: init: stmt relevant? _8 = (long unsigned int) i_19;

test4.c:14: note: init: stmt relevant? _9 = _8 * 8;

test4.c:14: note: init: stmt relevant? _10 = x_4 + _9;

test4.c:14: note: init: stmt relevant? _11 = *_10;

test4.c:14: note: init: stmt relevant? _12 = y_6 + _9;

test4.c:14: note: init: stmt relevant? _13 = *_12;

test4.c:14: note: init: stmt relevant? _14 = _11 + _13;

test4.c:14: note: init: stmt relevant? *_10 = _14;

test4.c:14: note: vec_stmt_relevant_p: stmt has vdefs.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: init: stmt relevant? i_16 = i_19 + 1;

test4.c:14: note: init: stmt relevant? ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: init: stmt relevant? if (ivtmp_31 != 0)

test4.c:14: note: worklist: examine stmt: *_10 = _14;

test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: worklist: examine stmt: _14 = _11 + _13;

test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: worklist: examine stmt: _13 = *_12;

test4.c:14: note: worklist: examine stmt: _11 = *_10;

test4.c:14: note: === vect_analyze_dependences ===
test4.c:14: note: dependence distance  = 0.
test4.c:14: note: dependence distance == 0 between *_10 and *_10
test4.c:14: note: === vect_determine_vectorization_factor ===
test4.c:14: note: ==> examining phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: ==> examining phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: ==> examining phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: ==> examining statement: _8 = (long unsigned int) i_19;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _9 = _8 * 8;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _10 = x_4 + _9;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _11 = *_10;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: _12 = y_6 + _9;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _13 = *_12;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: _14 = _11 + _13;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: *_10 = _14;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: i_16 = i_19 + 1;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: if (ivtmp_31 != 0)

test4.c:14: note: skip.
test4.c:14: note: vectorization factor = 2
test4.c:14: note: === vect_analyze_data_refs_alignment ===
test4.c:14: note: dependence distance  = 0.
test4.c:14: note: accesses have the same alignment.dependence distance modulo vf == 0 between *_10 and *_10
test4.c:14: note: vect_compute_data_ref_alignment:
test4.c:14: note: misalign = 0 bytes of ref *_10
test4.c:14: note: vect_compute_data_ref_alignment:
test4.c:14: note: misalign = 0 bytes of ref *_12
test4.c:14: note: vect_compute_data_ref_alignment:
test4.c:14: note: misalign = 0 bytes of ref *_10
test4.c:14: note: === vect_analyze_data_ref_accesses ===
test4.c:14: note: === vect_prune_runtime_alias_test_list ===
test4.c:14: note: === vect_enhance_data_refs_alignment ===
test4.c:14: note: vect_can_advance_ivs_p:
test4.c:14: note: Analyze phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: Access function of PHI: {0, +, 1}_1
test4.c:14: note: Analyze phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: virtual phi. skip.
test4.c:14: note: Analyze phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: Access function of PHI: {65536, +, 4294967295}_1
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
test4.c:14: note: vect_model_store_cost: aligned.
test4.c:14: note: vect_get_data_access_cost: inside_cost = 3, outside_cost = 0.
test4.c:14: note: === vect_analyze_slp ===
test4.c:14: note: === vect_make_slp_decision ===
test4.c:14: note: === vect_detect_hybrid_slp ===
test4.c:14: note: === vect_analyze_loop_operations ===
test4.c:14: note: examining phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: examining phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: examining phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: ==> examining statement: _8 = (long unsigned int) i_19;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _9 = _8 * 8;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _10 = x_4 + _9;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _11 = *_10;

test4.c:14: note: vect_is_simple_use: operand *_10
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_is_simple_use: operand *_10
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: _12 = y_6 + _9;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _13 = *_12;

test4.c:14: note: vect_is_simple_use: operand *_12
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_is_simple_use: operand *_12
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: _14 = _11 + _13;

test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: === vectorizable_operation ===
test4.c:14: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: *_10 = _14;

test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_model_store_cost: aligned.
test4.c:14: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: i_16 = i_19 + 1;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: if (ivtmp_31 != 0)

test4.c:14: note: irrelevant.
test4.c:14: note: vectorization_factor = 2, niters = 65536
test4.c:14: note: === vect_update_slp_costs_according_to_vf ===
test4.c:14: note: Cost model analysis: 
  Vector inside of loop cost: 4
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 4
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

test4.c:14: note:   Runtime profitability threshold = 1

test4.c:14: note:   Static estimate profitability threshold = 1


Vectorizing loop at test4.c:14

test4.c:14: note: === vec_transform_loop ===
test4.c:14: note: ------>vectorizing phi: i_19 = PHI <i_16(4), 0(6)>

test4.c:14: note: ------>vectorizing phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(6)>

test4.c:14: note: ------>vectorizing phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(6)>

test4.c:14: note: ------>vectorizing statement: _8 = (long unsigned int) i_19;

test4.c:14: note: ------>vectorizing statement: _9 = _8 * 8;

test4.c:14: note: ------>vectorizing statement: _10 = x_4 + _9;

test4.c:14: note: ------>vectorizing statement: _11 = *_10;

test4.c:14: note: transform statement.
test4.c:14: note: transform load. ncopies = 1
test4.c:14: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *x_4
test4.c:14: note: created vect_px.6_30
test4.c:14: note: add new stmt: vect_var_.7_24 = MEM[(double *)vect_px.3_26];

test4.c:14: note: ------>vectorizing statement: _12 = y_6 + _9;

test4.c:14: note: ------>vectorizing statement: _13 = *_12;

test4.c:14: note: transform statement.
test4.c:14: note: transform load. ncopies = 1
test4.c:14: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *y_6
test4.c:14: note: created vect_py.11_23
test4.c:14: note: add new stmt: vect_var_.12_18 = MEM[(double *)vect_py.8_22];

test4.c:14: note: ------>vectorizing statement: _14 = _11 + _13;

test4.c:14: note: transform statement.
test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: transform binary/unary operation.
test4.c:14: note: vect_get_vec_def_for_operand: _11
test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: def =  _11  def_stmt =  _11 = *_10;

test4.c:14: note: vect_get_vec_def_for_operand: _13
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: def =  _13  def_stmt =  _13 = *_12;

test4.c:14: note: add new stmt: vect_var_.13_17 = vect_var_.7_24 + vect_var_.12_18;

test4.c:14: note: ------>vectorizing statement: *_10 = _14;

test4.c:14: note: transform statement.
test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: transform store. ncopies = 1
test4.c:14: note: vect_get_vec_def_for_operand: _14
test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: def =  _14  def_stmt =  _14 = _11 + _13;

test4.c:14: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *x_4
test4.c:14: note: created vect_px.17_2
test4.c:14: note: add new stmt: MEM[(double *)vect_px.14_1] = vect_var_.13_17;

test4.c:14: note: ------>vectorizing statement: i_16 = i_19 + 1;

test4.c:14: note: ------>vectorizing statement: ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: ------>vectorizing statement: vect_px.3_25 = vect_px.3_26 + 16;

test4.c:14: note: ------>vectorizing statement: vect_py.8_21 = vect_py.8_22 + 16;

test4.c:14: note: ------>vectorizing statement: vect_px.14_29 = vect_px.14_1 + 16;

test4.c:14: note: ------>vectorizing statement: if (ivtmp_31 != 0)

loop at test4.c:16: if (ivtmp_27 < 32768)

test4.c:14: note: LOOP VECTORIZED.
test4.c:7: note: vectorized 1 loops in function.

test4.c:10: note: ===vect_slp_analyze_bb===

test4.c:10: note: === vect_analyze_data_refs ===

test4.c:10: note: not vectorized: not enough data-refs in basic block.

test4.c:16: note: ===vect_slp_analyze_bb===

test4.c:16: note: === vect_analyze_data_refs ===

test4.c:16: note: not vectorized: no vectype for stmt: vect_var_.7_24 = MEM[(double *)vect_px.3_26];
 scalar_type: vector(2) double
test4.c:16: note: === vect_pattern_recog ===
test4.c:16: note: === vect_analyze_dependences ===
test4.c:16: note: === vect_analyze_data_refs_alignment ===
test4.c:16: note: === vect_analyze_data_ref_accesses ===
test4.c:16: note: === vect_analyze_slp ===
test4.c:16: note: Failed to SLP the basic block.
test4.c:16: note: not vectorized: failed to find SLP opportunities in basic block.

test4.c:7: note: ===vect_slp_analyze_bb===

test4.c:7: note: === vect_analyze_data_refs ===

test4.c:7: note: not vectorized: not enough data-refs in basic block.

test4.c:18: note: ===vect_slp_analyze_bb===

test4.c:18: note: === vect_analyze_data_refs ===

test4.c:18: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at test4.c:14

test4.c:14: note: ===== analyze_loop_nest =====
test4.c:14: note: === vect_analyze_loop_form ===
test4.c:14: note: === get_loop_niters ===
test4.c:14: note: ==> get_loop_niters:65536
test4.c:14: note: === vect_analyze_data_refs ===

test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: === vect_analyze_scalar_cycles ===
test4.c:14: note: Analyze phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: Access function of PHI: {0, +, 1}_1
test4.c:14: note: step: 1,  init: 0
test4.c:14: note: Detected induction.
test4.c:14: note: Analyze phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: Analyze phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: Access function of PHI: {65536, +, 4294967295}_1
test4.c:14: note: step: 4294967295,  init: 65536
test4.c:14: note: Detected induction.
test4.c:14: note: === vect_pattern_recog ===
test4.c:14: note: vect_is_simple_use: operand _8
test4.c:14: note: def_stmt: _8 = (long unsigned int) i_19;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_is_simple_use: operand i_19
test4.c:14: note: def_stmt: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: type of def: 4.
test4.c:14: note: vect_is_simple_use: operand 8
test4.c:14: note: === vect_mark_stmts_to_be_vectorized ===
test4.c:14: note: init: phi relevant? i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: init: phi relevant? .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: init: phi relevant? ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: init: stmt relevant? _8 = (long unsigned int) i_19;

test4.c:14: note: init: stmt relevant? _9 = _8 * 8;

test4.c:14: note: init: stmt relevant? _10 = x_4 + _9;

test4.c:14: note: init: stmt relevant? _11 = *_10;

test4.c:14: note: init: stmt relevant? _12 = y_6 + _9;

test4.c:14: note: init: stmt relevant? _13 = *_12;

test4.c:14: note: init: stmt relevant? _14 = _11 + _13;

test4.c:14: note: init: stmt relevant? *_10 = _14;

test4.c:14: note: vec_stmt_relevant_p: stmt has vdefs.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: init: stmt relevant? i_16 = i_19 + 1;

test4.c:14: note: init: stmt relevant? ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: init: stmt relevant? if (ivtmp_31 != 0)

test4.c:14: note: worklist: examine stmt: *_10 = _14;

test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: worklist: examine stmt: _14 = _11 + _13;

test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: mark relevant 4, live 0.
test4.c:14: note: worklist: examine stmt: _13 = *_12;

test4.c:14: note: worklist: examine stmt: _11 = *_10;

test4.c:14: note: === vect_analyze_dependences ===
test4.c:14: note: dependence distance  = 0.
test4.c:14: note: dependence distance == 0 between *_10 and *_10
test4.c:14: note: === vect_determine_vectorization_factor ===
test4.c:14: note: ==> examining phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: ==> examining phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: ==> examining phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: ==> examining statement: _8 = (long unsigned int) i_19;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _9 = _8 * 8;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _10 = x_4 + _9;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _11 = *_10;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: _12 = y_6 + _9;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: _13 = *_12;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: _14 = _11 + _13;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: *_10 = _14;

test4.c:14: note: get vectype for scalar type:  double
test4.c:14: note: get vectype with 2 units of type double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: vectype: vector(2) double
test4.c:14: note: nunits = 2
test4.c:14: note: ==> examining statement: i_16 = i_19 + 1;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: skip.
test4.c:14: note: ==> examining statement: if (ivtmp_31 != 0)

test4.c:14: note: skip.
test4.c:14: note: vectorization factor = 2
test4.c:14: note: === vect_analyze_data_refs_alignment ===
test4.c:14: note: dependence distance  = 0.
test4.c:14: note: accesses have the same alignment.dependence distance modulo vf == 0 between *_10 and *_10
test4.c:14: note: vect_compute_data_ref_alignment:
test4.c:14: note: misalign = 0 bytes of ref *_10
test4.c:14: note: vect_compute_data_ref_alignment:
test4.c:14: note: misalign = 0 bytes of ref *_12
test4.c:14: note: vect_compute_data_ref_alignment:
test4.c:14: note: misalign = 0 bytes of ref *_10
test4.c:14: note: === vect_analyze_data_ref_accesses ===
test4.c:14: note: === vect_prune_runtime_alias_test_list ===
test4.c:14: note: === vect_enhance_data_refs_alignment ===
test4.c:14: note: vect_can_advance_ivs_p:
test4.c:14: note: Analyze phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: Access function of PHI: {0, +, 1}_1
test4.c:14: note: Analyze phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: virtual phi. skip.
test4.c:14: note: Analyze phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: Access function of PHI: {65536, +, 4294967295}_1
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
test4.c:14: note: vect_model_store_cost: aligned.
test4.c:14: note: vect_get_data_access_cost: inside_cost = 3, outside_cost = 0.
test4.c:14: note: === vect_analyze_slp ===
test4.c:14: note: === vect_make_slp_decision ===
test4.c:14: note: === vect_detect_hybrid_slp ===
test4.c:14: note: === vect_analyze_loop_operations ===
test4.c:14: note: examining phi: i_19 = PHI <i_16(4), 0(2)>

test4.c:14: note: examining phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(2)>

test4.c:14: note: examining phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(2)>

test4.c:14: note: ==> examining statement: _8 = (long unsigned int) i_19;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _9 = _8 * 8;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _10 = x_4 + _9;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _11 = *_10;

test4.c:14: note: vect_is_simple_use: operand *_10
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_is_simple_use: operand *_10
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: _12 = y_6 + _9;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: _13 = *_12;

test4.c:14: note: vect_is_simple_use: operand *_12
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_is_simple_use: operand *_12
test4.c:14: note: not ssa-name.
test4.c:14: note: use not simple.
test4.c:14: note: vect_model_load_cost: aligned.
test4.c:14: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: _14 = _11 + _13;

test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: === vectorizable_operation ===
test4.c:14: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: *_10 = _14;

test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_model_store_cost: aligned.
test4.c:14: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
test4.c:14: note: ==> examining statement: i_16 = i_19 + 1;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: irrelevant.
test4.c:14: note: ==> examining statement: if (ivtmp_31 != 0)

test4.c:14: note: irrelevant.
test4.c:14: note: vectorization_factor = 2, niters = 65536
test4.c:14: note: === vect_update_slp_costs_according_to_vf ===
test4.c:14: note: Cost model analysis: 
  Vector inside of loop cost: 4
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 4
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

test4.c:14: note:   Runtime profitability threshold = 1

test4.c:14: note:   Static estimate profitability threshold = 1


Vectorizing loop at test4.c:14

test4.c:14: note: === vec_transform_loop ===
test4.c:14: note: ------>vectorizing phi: i_19 = PHI <i_16(4), 0(6)>

test4.c:14: note: ------>vectorizing phi: .MEM_20 = PHI <.MEM_15(4), .MEM_7(D)(6)>

test4.c:14: note: ------>vectorizing phi: ivtmp_32 = PHI <ivtmp_31(4), 65536(6)>

test4.c:14: note: ------>vectorizing statement: _8 = (long unsigned int) i_19;

test4.c:14: note: ------>vectorizing statement: _9 = _8 * 8;

test4.c:14: note: ------>vectorizing statement: _10 = x_4 + _9;

test4.c:14: note: ------>vectorizing statement: _11 = *_10;

test4.c:14: note: transform statement.
test4.c:14: note: transform load. ncopies = 1
test4.c:14: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *x_4
test4.c:14: note: created vect_px.6_30
test4.c:14: note: add new stmt: vect_var_.7_24 = MEM[(double *)vect_px.3_26];

test4.c:14: note: ------>vectorizing statement: _12 = y_6 + _9;

test4.c:14: note: ------>vectorizing statement: _13 = *_12;

test4.c:14: note: transform statement.
test4.c:14: note: transform load. ncopies = 1
test4.c:14: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *y_6
test4.c:14: note: created vect_py.11_23
test4.c:14: note: add new stmt: vect_var_.12_18 = MEM[(double *)vect_py.8_22];

test4.c:14: note: ------>vectorizing statement: _14 = _11 + _13;

test4.c:14: note: transform statement.
test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: transform binary/unary operation.
test4.c:14: note: vect_get_vec_def_for_operand: _11
test4.c:14: note: vect_is_simple_use: operand _11
test4.c:14: note: def_stmt: _11 = *_10;

test4.c:14: note: type of def: 3.
test4.c:14: note: def =  _11  def_stmt =  _11 = *_10;

test4.c:14: note: vect_get_vec_def_for_operand: _13
test4.c:14: note: vect_is_simple_use: operand _13
test4.c:14: note: def_stmt: _13 = *_12;

test4.c:14: note: type of def: 3.
test4.c:14: note: def =  _13  def_stmt =  _13 = *_12;

test4.c:14: note: add new stmt: vect_var_.13_17 = vect_var_.7_24 + vect_var_.12_18;

test4.c:14: note: ------>vectorizing statement: *_10 = _14;

test4.c:14: note: transform statement.
test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: transform store. ncopies = 1
test4.c:14: note: vect_get_vec_def_for_operand: _14
test4.c:14: note: vect_is_simple_use: operand _14
test4.c:14: note: def_stmt: _14 = _11 + _13;

test4.c:14: note: type of def: 3.
test4.c:14: note: def =  _14  def_stmt =  _14 = _11 + _13;

test4.c:14: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *x_4
test4.c:14: note: created vect_px.17_2
test4.c:14: note: add new stmt: MEM[(double *)vect_px.14_1] = vect_var_.13_17;

test4.c:14: note: ------>vectorizing statement: i_16 = i_19 + 1;

test4.c:14: note: ------>vectorizing statement: ivtmp_31 = ivtmp_32 - 1;

test4.c:14: note: ------>vectorizing statement: vect_px.3_25 = vect_px.3_26 + 16;

test4.c:14: note: ------>vectorizing statement: vect_py.8_21 = vect_py.8_22 + 16;

test4.c:14: note: ------>vectorizing statement: vect_px.14_29 = vect_px.14_1 + 16;

test4.c:14: note: ------>vectorizing statement: if (ivtmp_31 != 0)

loop at test4.c:16: if (ivtmp_27 < 32768)

test4.c:14: note: LOOP VECTORIZED.
test4.c:7: note: vectorized 1 loops in function.

test4.c:10: note: ===vect_slp_analyze_bb===

test4.c:10: note: === vect_analyze_data_refs ===

test4.c:10: note: not vectorized: not enough data-refs in basic block.

test4.c:16: note: ===vect_slp_analyze_bb===

test4.c:16: note: === vect_analyze_data_refs ===

test4.c:16: note: not vectorized: no vectype for stmt: vect_var_.7_24 = MEM[(double *)vect_px.3_26];
 scalar_type: vector(2) double
test4.c:16: note: === vect_pattern_recog ===
test4.c:16: note: === vect_analyze_dependences ===
test4.c:16: note: === vect_analyze_data_refs_alignment ===
test4.c:16: note: === vect_analyze_data_ref_accesses ===
test4.c:16: note: === vect_analyze_slp ===
test4.c:16: note: Failed to SLP the basic block.
test4.c:16: note: not vectorized: failed to find SLP opportunities in basic block.

test4.c:7: note: ===vect_slp_analyze_bb===

test4.c:7: note: === vect_analyze_data_refs ===

test4.c:7: note: not vectorized: not enough data-refs in basic block.

test4.c:18: note: ===vect_slp_analyze_bb===

test4.c:18: note: === vect_analyze_data_refs ===

test4.c:18: note: not vectorized: not enough data-refs in basic block.
